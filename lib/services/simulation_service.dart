import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import '../models/vehicle_config.dart';
import '../models/simulation_result.dart';

class SimulationService {
  // This tells the app where to look for the engine.
  // We assume the 'backend' folder is in the root of the project for debug builds.
  static const String _executableName = 'Lap_Sim_CLI.exe';
  
  Future<SimulationResult> runSimulation(VehicleConfig config) async {
    try {
      // 1. Setup Paths
      // We use a temporary directory for JSON files to avoid clutter
      final tempDir = await getTemporaryDirectory();
      final inputPath = p.join(tempDir.path, 'input.json');
      final outputPath = p.join(tempDir.path, 'output.json');

      // 2. Locate the Executable (Dynamic Logic)
      // For development (Debug mode), we look in the project root/backend.
      // For release, you might place it differently. 
      final projectRoot = Directory.current.path; 
      final exePath = p.join(projectRoot, 'backend', _executableName);

      // Verify exe exists before trying to run
      if (!await File(exePath).exists()) {
        throw Exception("Backend engine not found at: $exePath\nMake sure 'backend/Lap_Sim_CLI.exe' exists.");
      }

      // 3. Write Input JSON
      final jsonString = jsonEncode(config.toJson());
      await File(inputPath).writeAsString(jsonString);

      // 4. Run the MATLAB Executable
      // We pass input and output paths as arguments
      print("Running Simulation: $exePath");
      final result = await Process.run(
        exePath, 
        [inputPath, outputPath],
        runInShell: true, 
      );

      // 5. Check for Subprocess Errors
      if (result.exitCode != 0) {
        print("Simulation Failed Stderr: ${result.stderr}");
        print("Simulation Failed Stdout: ${result.stdout}");
        throw Exception("Simulation Engine Failed (Exit Code ${result.exitCode}). See console for details.");
      }

      // 6. Read & Parse Output JSON
      final outputFile = File(outputPath);
      if (!await outputFile.exists()) {
        throw Exception("Output file was not generated by the simulation engine.");
      }

      final outputString = await outputFile.readAsString();
      final Map<String, dynamic> outputJson = jsonDecode(outputString);

      // 7. Cleanup (Optional: keep files for debugging if needed)
      // await outputFile.delete(); 
      // await File(inputPath).delete();

      return SimulationResult.fromJson(outputJson);

    } catch (e) {
      print("Simulation Error: $e");
      rethrow; // Pass error up to the UI to show a snackbar
    }
  }
}